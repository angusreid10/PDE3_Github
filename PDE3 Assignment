{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "8c2aefcf",
   "metadata": {},
   "source": [
    "# Partial Differential Equations 3: Coursework\n",
    "\n",
    "Complete all the questions below in the sections marked 'Solution'. Then convert this page to a pdf file by using 'File/Print Preview'. Then click on the dotted symbol at the top-right of your webpage and choose 'Print', or press 'Ctrl+P', and save your document as a pdf file. Make sure you select 1 page per sheet in the 'more settings' section. Then submit your pdf file via Learn to the Coursework dropbox.\n",
    "\n",
    "Do not alter the standard format of this Jupyter Notebook. Marks for this coursework will be awarded for the correctness of the solution as well as for the clarity and logical progression of your explanation and your presentation and layout of the solution. You will need to write equations using LaTeX embedded within this Jupyter Notebook. See this notebook and other tutorial or computing workbooks for examples of how this is achieved. Tutorials can also be found online. You will also need to add or complete code 'snippets' using separate code sections within this Notebook.\n",
    "\n",
    "\n",
    "## Q1 (50 marks)\n",
    "\n",
    "Consider the one-dimensional heat conduction equation\n",
    "\n",
    "\\begin{align}\n",
    "\\frac{\\partial u(x,t)}{\\partial t} &= \\kappa \\frac{\\partial^2 u(x,t)}{\\partial x^2} \\tag{a}\n",
    "\\end{align}\n",
    "\n",
    "on the interval $0<x<0.5\\pi$ with the initial condition \n",
    "\n",
    "$$u(x,0) = \\sin(x), \\quad 0\\le x< 0.5\\pi, \\tag{b} $$\n",
    "\n",
    "and the boundary conditions\n",
    "\n",
    "\\begin{align}\n",
    "u(0,t) &= g_0(t), \\quad \\forall t\\ge0, \\tag{c} \\\\\n",
    "u(0.5\\pi, t)&= g_1(t), \\quad \\forall t\\ge0. \\tag{d} \n",
    "\\end{align}\n",
    "\n",
    "__a)__ By using the Laplace transform method with respect to time $t$ show that the Laplace domain solution is\n",
    "\n",
    "\\begin{align}\n",
    "U(x,s) =& \\frac{G_1(s) - \\frac{1}{s+\\kappa}}{\\sinh\\left(0.5\\pi\\sqrt{\\frac{s}{\\kappa}}\\right)}\\sinh\\left(x\\sqrt{\\frac{s}{\\kappa}}\\right) + \\frac{G_0(s)}{\\sinh\\left(0.5\\pi\\sqrt{\\frac{s}{\\kappa}}\\right)}\\sinh\\left((0.5\\pi-x)\\sqrt{\\frac{s}{\\kappa}}\\right) + \\frac{\\sin(x)}{s + \\kappa}\n",
    "\\end{align}\n",
    "\n",
    "where $G_0(s)$ and $G_1(s)$ are the laplace transforms of $g_0(t)$ and $g_1(t)$ respectively.\n",
    "\\\n",
    "\\\n",
    "__Solution (25 marks)__\n",
    "\n",
    "\n",
    "__b)__ Now consider the specific boundary conditions\n",
    "\n",
    "\\begin{align}\n",
    "u(0,t) &= g_0(t) = t, \\quad &\\forall t\\ge0,\\\\\n",
    "u(0.5\\pi, t)&= g_1(t) = \\exp(-\\kappa t), \\quad &\\forall t\\ge0.\n",
    "\\end{align}\n",
    "\n",
    "Find the time domain solution.\n",
    "\n",
    "__Hint:__\n",
    "\n",
    "The Laplace domain function\n",
    "\n",
    "$$\n",
    "F(s) = \\frac{\\sinh(b\\sqrt{s})}{s^2\\sinh(a\\sqrt{s})}\n",
    "$$\n",
    "\n",
    "has the inverse transform\n",
    "\\begin{align}\n",
    "f(t) =& \\frac{bt}{a} + \\frac{2a^2}{\\pi^3} \\sum_{n=1}^\\infty \\frac{(-1)^n}{n^3}\\left(1 - e^{-n^2\\pi^2 t/a^2}\\right) \\sin\\left(\\frac{n\\pi b}{a}\\right)\n",
    "\\end{align}\n",
    "\\\n",
    "\\\n",
    "__Solution (15 marks)__\n",
    "\n",
    "\\\n",
    "\\\n",
    "__c)__ Provide a 3-d plot of your solution below for $\\kappa=0.2$ between $0\\le t\\le 5$. __(10 marks)__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "fbaef192",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# PLOT YOUR SOLUTION HERE\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7124a67c",
   "metadata": {},
   "source": [
    "## Q2 (50 marks)\n",
    "\n",
    "You are to use the two dimensional form of the Crank-Nicholson method to solve the isotropic heat conduction equation,\n",
    "\n",
    "$$\\frac{\\partial T}{\\partial t} = \\kappa\\left(\\frac{\\partial^2 T}{\\partial x^2}+\\frac{\\partial^2 T}{\\partial y^2}\\right).$$\n",
    "\n",
    "The <code>Grid</code> class, below, will be used to generate the grid for this solver. It has been extended to include an additional variable for time (<code>self.time</code>) in the grid object and to ensure that this is zero when the grid is created. The time variable will be needed later by the boundary condition routines.  The class also includes <code>self.kappa</code> variable, which is used to store the thermal diffusivity. \n",
    "\n",
    "The problem addressed with its boundary conditions is presented below after the definition of the Grid class.\n",
    "\n",
    "The <code>class Grid</code> code is complete, while for the rest of the problem, parts of Python code are provided with certain sections missing, which are for you to fill in. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "eb433216-30f8-4336-a10f-8d6a59595d24",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import time\n",
    "\n",
    "class Grid:\n",
    "    '''Class defining a 2D computational grid.  The grid object\n",
    "    contains is a regular cartesian grid with a single variable, u.\n",
    "    It stores information about the number of grid points in the i\n",
    "    and j directions, the coordinates of these points and the bottom\n",
    "    left corner of the grid (the origin) and the top right corner\n",
    "    (the extent).\n",
    "    \n",
    "    Written by Prof David Ingram, School of Engineering\n",
    "    (c) 2022 The University of Edinburgh\n",
    "    Licensed under CC-BY-NC.'''\n",
    "    \n",
    "    DIRICHLET_BC = 0\n",
    "    NEUMANN_BC = 1\n",
    "\n",
    "    BC_NAME = ['left', 'right', 'top', 'bottom']\n",
    "    \n",
    "    def __init__(self,ni,nj):\n",
    "        # Set up information about the grid\n",
    "        self.origin = (0.0, 0.0)  # bottom left\n",
    "        self.extent = (1.0, 1.0)  # top right\n",
    "        self.Ni = ni # grid points in i direction\n",
    "        self.Nj = nj # grid points in j direction\n",
    "        \n",
    "        # Initialse x,y and u arrays\n",
    "        self.u = np.zeros((nj, ni))\n",
    "        self.x = np.zeros((nj, ni))\n",
    "        self.y = np.zeros((nj, ni))\n",
    "        \n",
    "        # Boundary conditions (left right top and bottom)\n",
    "        self.BC = [self.DIRICHLET_BC, self.DIRICHLET_BC, \n",
    "                   self.DIRICHLET_BC, self.DIRICHLET_BC]\n",
    "        \n",
    "        # Set the time\n",
    "        self.time = 0.0\n",
    "        \n",
    "        # Initialize thermal diffusivity\n",
    "        self.kappa = 1.0\n",
    "\n",
    "    def set_origin(self,x0,y0):\n",
    "        \n",
    "        # Set origin of domain\n",
    "        self.origin = (x0, y0)\n",
    "    \n",
    "    def set_extent(self,width,height):\n",
    "        \n",
    "        # Set extent of domain\n",
    "        self.extent = (width, height)\n",
    "        \n",
    "    def generate(self,Quiet=True):\n",
    "        '''generate a uniformly spaced grid covering the domain from the\n",
    "        origin to the extent.  We are going to do this using linspace from\n",
    "        numpy to create lists of x and y ordinates and then the meshgrid\n",
    "        function to turn these into 2D arrays of grid point ordinates.'''\n",
    "        x_ord = np.linspace(self.origin[0], self.origin[0]+self.extent[0], self.Ni)\n",
    "        y_ord = np.linspace(self.origin[1], self.origin[1]+self.extent[1], self.Nj)\n",
    "        self.x, self.y = np.meshgrid(x_ord,y_ord)\n",
    "        if not Quiet:\n",
    "            print(self)\n",
    "\n",
    "    def set_diffusivity(self,k):\n",
    "        self.kappa = k\n",
    "        \n",
    "    def Delta_x(self):\n",
    "        # Calculate delta x\n",
    "        dx = self.x[0,1]-self.x[0,0]\n",
    "        \n",
    "        return dx\n",
    "    \n",
    "    def Delta_y(self):\n",
    "        # Calculate delta y\n",
    "        dy = self.y[1,0]-self.y[0,0]\n",
    "        \n",
    "        return dy\n",
    "    \n",
    "    def find(self,point):\n",
    "        '''find the i and j ordinates of the grid cell which contains \n",
    "        the point (x,y).  To do this we calculate the distance from\n",
    "        the point to the origin in the x and y directions and then\n",
    "        divide this by delta x and delta y.  The resulting real ordinates\n",
    "        are converted to indices using the int() function.'''\n",
    "        grid_x = (point[0] - self.origin[0])/self.Delta_x()\n",
    "        grid_y = (point[1] - self.origin[1])/self.Delta_y()\n",
    "        return int(grid_x), int(grid_y)\n",
    "    \n",
    "    def set_Neumann_bc(self,side):\n",
    "        try:\n",
    "             self.BC[self.BC_NAME.index(side)] = self.NEUMANN_BC\n",
    "        except:\n",
    "             print('error {} must be one of {}'.format(side,self.BC_NAME))\n",
    "     \n",
    "    def set_Dirichlet_bc(self,side):\n",
    "        try:\n",
    "            self.BC[self.BC_NAME.index(side)] = self.DIRICHLET_BC\n",
    "        except:\n",
    "            print('error {} must be one of {}'.format(side,self.BC_NAME))\n",
    "    \n",
    "    def plot(self,title):\n",
    "        '''produce a contour plot of the solution at the current time'''\n",
    "        \n",
    "        # Create a figure title\n",
    "        caption = f'{title}, t={self.time}s ({self.Ni} x {self.Nj}) grid.'\n",
    "        \n",
    "        # Create a figure and add a plot to it\n",
    "        fig, ax1 = plt.subplots()\n",
    "        \n",
    "        # Draw the contour plot\n",
    "        cmap = plt.get_cmap('jet')\n",
    "        cf = ax1.contourf(self.x,self.y,self.u,cmap=cmap, levels = 21)\n",
    "        \n",
    "        # Add colorbar\n",
    "        fig.colorbar(cf, ax=ax1)\n",
    "        \n",
    "        # Set title\n",
    "        ax1.set_title(caption)\n",
    "        return plt\n",
    "\n",
    "     \n",
    "    def report_BC(self):\n",
    "        '''compile a string listing the boundary conditions on each side.\n",
    "        We build up a string of four {side name}: {BC type} pairs and\n",
    "        return it'''\n",
    "        \n",
    "        # Initialise the string\n",
    "        string = ''\n",
    "        \n",
    "        # loop over the sides\n",
    "        for side in range(4):\n",
    "            # Add the side name\n",
    "            string = string + self.BC_NAME[side]\n",
    "            # And the boundary condition type\n",
    "            if self.BC[side] == self.DIRICHLET_BC:\n",
    "                string = string + ': Dirichlet, '\n",
    "            elif self.BC[side] == self.NEUMANN_BC:\n",
    "                string = string + ': Neumann, '\n",
    "        return string[:-2] +'.' # Lose the last comma and space.\n",
    "    \n",
    "    def __str__(self):\n",
    "        # Description of the object when asked to print it\n",
    "        describe = 'Uniform {}x{} grid from {} to {}.'.format(self.Ni, self.Nj, self.origin, self.origin+self.extent)\n",
    "        boundaries = self.report_BC()\n",
    "        return describe + '\\n The boundary conditions are - ' + boundaries +f'\\ntime ={self.time:.4g}'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb1a8f7e-e499-4c86-a778-50acbe9d58df",
   "metadata": {},
   "source": [
    "## The problem\n",
    "The following PDE is to be solved\n",
    "$$\n",
    "\\frac{\\partial u(x,y,t)}{\\partial t} = \\kappa \\left(\\frac{\\partial^2 u(x,y,t)}{\\partial x^2}+\\frac{\\partial^2 u(x,y,t)}{\\partial y^2}\\right) \\label{eq:2D_PDE}\n",
    "$$\n",
    "on the interval $$0\\le x\\le0.5\\pi \\\\ -\\pi \\le y\\le \\pi$$ with the initial condition\n",
    "$$\n",
    "\\begin{equation*}u(x,y,0) = \\sin(x)  \\quad\\quad 0\\le x \\le0.5\\pi \\; , \\;-\\pi\\le y\\le \\pi \\end{equation*}\n",
    "$$\n",
    "and the boundary conditions\n",
    "\n",
    "$$\\begin{align}\n",
    "u(0,y,t) &= t &\\quad \\forall t\\ge0, \\qquad &-\\pi\\le y\\le \\pi, \\label{eq:2D_left_boundary} \\\\\n",
    "u\\left(0.5\\pi,y,t\\right) &= \\exp(-\\kappa t) &\\quad \\forall t\\ge0, \\qquad &-\\pi\\le y\\le \\pi, \\label{eq:2D_right_boundary} \\\\\n",
    "u\\left(x,-\\pi,t\\right) &= 0 &\\quad \\forall t\\ge0, \\qquad &0\\le x \\le0.5\\pi,\\label{eq:2D_bottom_boundary} \\\\\n",
    "u\\left(x, \\pi,t\\right) &= 2\\cos(x)\\exp(-\\kappa t) &\\quad \\forall t\\ge0, \\qquad &0\\le x \\le0.5\\pi,\\label{eq:2D_top_boundary} \\end{align}$$\n",
    "\n",
    "\n",
    "As in the analytical part, $\\kappa=0.2$.\n",
    "\n",
    "__a)__ Set up the grid, the initial and boundary conditions by completing the __Python__ code below. Explain how the boundary conditions are implemented in the code. __(10 marks)__\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82d1d4ae-7171-44e1-9d6a-1e5bf1210048",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "def set_grid(ni,nj):\n",
    "    ''' This function sets up an ni x nj grid to solve the problem specified in the Coursework'''\n",
    "    \n",
    "    # Initialize the grid class with ni and nj grid points\n",
    "    mesh = Grid(ni,nj)\n",
    "    \n",
    "    # Set origin and extent of grid\n",
    "    mesh.set_origin( , )\n",
    "    mesh.set_extent( , )\n",
    "    \n",
    "    # Set diffusivity\n",
    "    mesh.set_diffusivity( )\n",
    "    \n",
    "    # This generates the grid\n",
    "    mesh.generate()\n",
    "     \n",
    "    # Now set the inital conditions\n",
    "    mesh.u = \n",
    "    \n",
    "    return mesh\n",
    "\n",
    "def set_boundary_conditions(mesh,time):\n",
    "    '''Function that sets the boundary conditions. This functions takes \n",
    "       as input a mesh (mesh) and a time step (time)'''\n",
    "    \n",
    "    # Set x = 0 boundary\n",
    "    mesh.u[ , ] = \n",
    "    \n",
    "    # Set x = 0.5pi boundary\n",
    "    mesh.u[ , ] = \n",
    "    \n",
    "    # Set y boundaries\n",
    "    mesh.u[ , ] = \n",
    "    mesh.u[ , ] = \n",
    "\n",
    "# This creates a 121 by 121 grid\n",
    "grid = set_grid(121, 121)\n",
    "\n",
    "# Call the function to set up boundary conditions for the first time step (t=0)\n",
    "set_boundary_conditions(grid, 0.0)\n",
    "\n",
    "# Plot the initial solution matrix - Check that initial and boundary conditions are implemented correctly!\n",
    "grid.plot('Coursework')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0c1c981c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Explain how the boundary conditions are implemented here (Convert cell to markdown)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4dc8924d-db13-45bd-a073-17e46ad50198",
   "metadata": {},
   "source": [
    "__b)__ Derive the 2D Crank-Nicholson scheme by using the appropriate finite difference approximations of the derivatives, stating its formal order of accuracy in time and space. Specify also the coefficients of the solution at the current point and its neighbouring points in the 2D Crank-Nicholson equation. This part requires writing the equations to derive the 2D Crank-Nicholson scheme and does not involve writing Python code. __(10 marks)__\n",
    "\n",
    "__Solution__\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "40cbfa60",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "f08b565c",
   "metadata": {},
   "source": [
    "__c)__ Complete the following __Python__ code which implements the Crank-Nicholson solver in 2D using the Bi-conjugate gradient stabilised linear algebra solver. __(20 marks)__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "bf12f07f-0937-4aba-9807-d32e5f9a3543",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import scipy.sparse as sps\n",
    "import scipy.sparse.linalg as LA\n",
    "\n",
    "def Crank_Nicholson(mesh,t_stop,Courant_no=5.0):\n",
    "    '''Advance the solution from the current time to t=t_stop\n",
    "    using the Crank-Nicholson method.\n",
    "    \n",
    "    mesh is an object of the grid class, \n",
    "    t_stop is the time at which the solution is required and \n",
    "    Courant_no is the Courant number to be used for the calculation.  \n",
    "    While the Crank-Nicholson method is unconditionally stable, a low\n",
    "    Courant number is recommended on grounds of accuracy.'''\n",
    "    \n",
    "    # Calculate delta_t based on the Courant Number \n",
    "    delta_t = Courant_no*min( , )\n",
    "    \n",
    "    # Calculate number of iterations based on stopping time t_stop and time step delta_t\n",
    "    maxit = int((t_stop-mesh.time)/delta_t)\n",
    "    \n",
    "    # We set a variable of every how many iterations (time steps) to report\n",
    "    out_it = maxit // 50\n",
    "    \n",
    "    print('Crank Nicholson with ∆t={:.4g} ({:d} times steps)'.format(delta_t,maxit))\n",
    "    \n",
    "    # Initialize the A matrix using the lil format (sparse matrix) and the b vector as a numpy vector.\n",
    "    N = (grid.Nj-2)*(grid.Ni-2) # How many interior points our solution grid has\n",
    "    A_mat = sps.lil_matrix((N, N), dtype=np.float64)\n",
    "    b_vec = np.zeros(N, dtype=np.float64)\n",
    "    \n",
    "    # Initialize the solution vector\n",
    "    x_vec = np.zeros(N, dtype=np.float64)\n",
    "    \n",
    "\n",
    "    # Calculate rx and ry coefficients\n",
    "    rx = \n",
    "    ry = \n",
    "\n",
    "    # Now build the A and B matricies\n",
    "    for i in range(1,mesh.Ni-1):\n",
    "        for j in range(1,mesh.Nj-1):\n",
    "            # We introduce index k\n",
    "            k = (i-1) + (mesh.Ni-2)*(j-1)\n",
    "                \n",
    "            # Set the leading diagonal coefficient\n",
    "            A_mat[k,k] = \n",
    "               \n",
    "            # Set coefficients of neighbouring points in the i direction\n",
    "            for m in range(i-1,i+2,2):\n",
    "                if not(m<1 or m>mesh.Ni-2):\n",
    "                    l = (m-1) + (mesh.Ni-2)*(j-1)\n",
    "                    A_mat[k,l] = \n",
    "\n",
    "            # Set coefficients of neighbouring points in the j direction\n",
    "            for m in range(j-1,j+2,2):\n",
    "                if not(m<1 or m>mesh.Nj-2):\n",
    "                    l = (i-1) + (mesh.Ni-2)*(m-1)\n",
    "                    A_mat[k,l] = \n",
    "    \n",
    "    # Assemble the preconditioner\n",
    "    ilu = LA.spilu(A_mat.tocsc(), drop_tol=1e-6, fill_factor=100)\n",
    "    M_mat = LA.LinearOperator(A_mat.shape, ilu.solve)\n",
    "\n",
    "    # Set an iteration counter\n",
    "    it = 0\n",
    "        \n",
    "    # Set a variable for the convergence status. This is set initially to 1, which means convergence not achieved. \n",
    "    # The LA.bicgstab will return status = 0 when we have successful convergence.\n",
    "    status = 1\n",
    "    \n",
    "    # Start the time loop - Every iteration is a time step\n",
    "    while mesh.time < t_stop:\n",
    "        \n",
    "        # Progress counter\n",
    "        if it % out_it ==0:\n",
    "            print('#',end='')\n",
    "            \n",
    "        # Calculate time step dt - Ensure we don't overshoot the stop time\n",
    "        dt = min(delta_t, t_stop-mesh.time)\n",
    "        \n",
    "        # Set the boundary conditions\n",
    "        set_boundary_conditions(mesh, mesh.time)\n",
    "        \n",
    "        # Extract the x_vector - We take the interior points of the 2D solution array (mesh.u[1:-1,1:-1]) and we reshape\n",
    "        # that into a vector (1D array) with N elements\n",
    "        x_vec = np.reshape(mesh.u[1:-1,1:-1],(N))\n",
    "\n",
    "        # Calculate the b vector (RHS) using the values from the current time step\n",
    "        for i in range(1,mesh.Ni-1):\n",
    "            for j in range(1,mesh.Nj-1):\n",
    "                k = (i-1) + (mesh.Ni-2)*(j-1)\n",
    "                \n",
    "                # Calculate b(k) from the stencil for the current time step\n",
    "                b_vec[k] = \n",
    " \n",
    "        # Now apply the boundary conditions for the next time level\n",
    "        set_boundary_conditions(mesh, mesh.time+dt)\n",
    "\n",
    "        # Update the b vector to include boundary conditions\n",
    "        for i in range(1,mesh.Ni-1):\n",
    "            for j in range(1,mesh.Nj-1):\n",
    "                k = (i-1) + (mesh.Ni-2)*(j-1)\n",
    "                \n",
    "                # i direction\n",
    "                for m in range(i-1,i+2,2):\n",
    "                    if m<1 or m>mesh.Ni-2:\n",
    "                        b_vec[k] += \n",
    "\n",
    "                # j direction\n",
    "                for m in range(j-1,j+2,2):\n",
    "                    if m<1 or m>mesh.Nj-2:\n",
    "                        b_vec[k] += \n",
    "                        \n",
    "        # Solve the matrix system Ax=b using the preconditioner M\n",
    "        x_vec, status = LA.bicgstab(A_mat, b_vec, x0=x_vec, M=M_mat)\n",
    "        \n",
    "        # If status=0 is returned then we have convergence. If not, convergence not achieved and we break the loop\n",
    "        if status==0:\n",
    "            # Out solution is in the format of a vector (x_vec - 1D array). We need to unpack this into a 2D grid (2D array)\n",
    "            mesh.u[1:-1,1:-1] = np.reshape(x_vec, (mesh.Ni-2,mesh.Nj-2))\n",
    "        if status != 0:\n",
    "            break\n",
    "        \n",
    "        # Update time step and iteration number for next step\n",
    "        mesh.time += dt\n",
    "        it += 1\n",
    "    \n",
    "    print('.')\n",
    "    if status == 0:\n",
    "        return it\n",
    "    else:\n",
    "        return -status"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "445d1339-b8c3-4b95-be92-c43bb0925c3e",
   "metadata": {},
   "source": [
    "__d)__ Calculate the solution at time $t=5$s.  Compare the numerical solution at $y=0$ with the analytical solution from question Q1. Comment on the accuracy of the method and the computational effort needed. __(10 Marks)__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f8544e2-6dfd-44c2-ad84-4678a490d72d",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "it = Crank_Nicholson( , )\n",
    "\n",
    "# Prints how many iterations were performed\n",
    "print(it,'iterations completed.')\n",
    "\n",
    "# Plots solution\n",
    "grid.plot('Coursework')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70df5039",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compare numerical and analytical solution\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0b8e0300-1417-40a8-bc2d-346cd1f6cf45",
   "metadata": {},
   "source": [
    "Write your comments for 2d) here...\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de443fc5",
   "metadata": {},
   "source": [
    "$\\\\[3cm]$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2fd09dc2",
   "metadata": {},
   "source": [
    "__Properties of the unilateral Laplace transform__\n",
    "\n",
    "|Property | $f(t), t\\ge0$ | $F(s)$ |\n",
    "| :-: | :-: | :-: |\n",
    "|Definition | $f(t)$ | $\\int_0^\\infty\\exp(-st)f(t)dt$ |\n",
    "|Inversion | $\\frac{1}{j2\\pi}\\int_{c-j\\infty}^{c+j\\infty} \\exp(st)F(s)ds$ | $F(s)$ |\n",
    "|Linearity | $\\alpha f(t) + \\beta g(t)$ | $\\alpha F(s) + \\beta G(s)$ |\n",
    "|Scaling | $f(\\alpha t)$ | $\\frac{1}{\\alpha}F\\left(\\frac{s}{\\alpha}\\right)$ |\n",
    "|Frequency shifting | $\\exp(\\alpha t)f(t)$ | $F(s-\\alpha)$ |\n",
    "|Time shifting | $f(t-\\alpha) H(t-\\alpha)$ | $\\exp(-\\alpha s)F(s)$ |\n",
    "|First derivative | $f'(t)$ | $sF(s) - f(0)$ |\n",
    "|nth derivative | $f^{(n)}(t)$ | $s^nF(s)-s^{n-1}f(0)-s^{n-2}f'(0) \\dots -s f^{(n-2)}(0) - f^{(n-1)}(0)$ |\n",
    "|Transform derivative | $t^n f(t)$ | $(-1)^n \\frac{d^n F(s)}{ds^n}$ |      \n",
    "|Integration | $\\int_0^t f(\\tau)d\\tau$ | $\\frac{1}{s}F(s)$ |\n",
    "\n",
    "__Function transforms__\n",
    "\n",
    "|Name | $f(t), t\\ge0$ | $F(s)$ | Convergence region |\n",
    "| :-: | :-: | :-: | :-: |\n",
    "|Unit impulse | $\\delta(t)$ | $1$ | all $s$ |\n",
    "|Ideal delay | $\\delta(t-\\alpha)$ | $\\exp(-\\alpha s)$ | $\\Re(s)\\ge\\alpha$ |\n",
    "|Unit step | $H(t)$ | $\\frac{1}{s}$ | $\\Re(s)>0$ |\n",
    "|Ramp  | $t$ | $\\frac{1}{s^2}$ | $\\Re(s)>0$ |\n",
    "|nth power  | $t^n, n=1,2,\\dots$ | $\\frac{n!}{s^{n+1}}$ | $\\Re(s)>0$ |\n",
    "|Sine | $\\sin(\\alpha t)$ | $\\frac{\\alpha}{s^2 + \\alpha^2}$ | $\\Re(s)>0$ |\n",
    "|Cosine | $\\cos(\\alpha t)$ | $\\frac{s}{s^2 + \\alpha^2}$ | $\\Re(s)>0$ |\n",
    "|Hyperbolic sine | $\\sinh(\\alpha t)$ | $\\frac{\\alpha}{s^2 - \\alpha^2}$ | $\\Re(s)>|\\alpha|$ |\n",
    "|Hyperbolic cosine | $\\cosh(\\alpha t)$ | $\\frac{s}{s^2 - \\alpha^2}$ | $\\Re(s)>|\\alpha|$ |\n",
    "|Exponential decay | $\\exp(-\\alpha t)$ | $\\frac{1}{s + \\alpha}$ | $\\Re(s)>-\\alpha$ |\n",
    "|First moment of exponential decay | $t\\exp(-\\alpha t)$ | $\\frac{1}{(s + \\alpha)^2}$ | $\\Re(s)>-\\alpha $ |\n",
    "|Ramp hyperbolic sine | $t\\sinh(\\alpha t)$ | $\\frac{2\\alpha s}{(s^2 - \\alpha^2)^2}$ | $\\Re(s)>|\\alpha|$ |\n",
    "|Complementary error function  | $\\text{erfc}\\left(\\frac{k}{2\\sqrt{t}}\\right)$ | $\\frac{1}{s}\\exp\\left(-k\\sqrt{s}\\right)$ | $\\Re(s)\\ge0$ |"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cdc5c63e",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
